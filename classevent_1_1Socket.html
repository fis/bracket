<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>bracket: event::Socket Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">bracket
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classevent_1_1Socket.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classevent_1_1Socket-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">event::Socket Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Asynchronous (plain or TLS) socket.  
 <a href="classevent_1_1Socket.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="socket_8h_source.html">socket.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for event::Socket:</div>
<div class="dyncontent">
<div class="center"><img src="classevent_1_1Socket__inherit__graph.png" border="0" usemap="#event_1_1Socket_inherit__map" alt="Inheritance graph"/></div>
<map name="event_1_1Socket_inherit__map" id="event_1_1Socket_inherit__map">
<area shape="rect" id="node2" href="classevent_1_1internal_1_1BasicSocket.html" title="Plain TCP socket. " alt="" coords="5,80,192,107"/>
<area shape="rect" id="node3" href="classevent_1_1internal_1_1TlsSocket.html" title="BoringSSL TLS socket. " alt="" coords="216,80,387,107"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevent_1_1Socket_1_1Builder.html">Builder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options to construct a socket.  <a href="classevent_1_1Socket_1_1Builder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevent_1_1Socket_1_1Exception.html">Exception</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classevent_1_1Socket_1_1Exception.html" title="Exception class for indicating socket I/O errors. ">Exception</a> class for indicating socket I/O errors.  <a href="classevent_1_1Socket_1_1Exception.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structevent_1_1Socket_1_1Watcher.html">Watcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback interface for asynchronous socket IO.  <a href="structevent_1_1Socket_1_1Watcher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac059ff70cae994ce2e95067ac81b93ef"><td class="memItemLeft" align="right" valign="top"><a id="ac059ff70cae994ce2e95067ac81b93ef"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>DISALLOW_COPY</b> (<a class="el" href="classevent_1_1Socket.html">Socket</a>)</td></tr>
<tr class="separator:ac059ff70cae994ce2e95067ac81b93ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30b24bea86c1560fc6e40615d7e22ec4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevent_1_1Socket.html#a30b24bea86c1560fc6e40615d7e22ec4">StartRead</a> ()=0</td></tr>
<tr class="memdesc:a30b24bea86c1560fc6e40615d7e22ec4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiates an asynchronous read operation.  <a href="#a30b24bea86c1560fc6e40615d7e22ec4">More...</a><br /></td></tr>
<tr class="separator:a30b24bea86c1560fc6e40615d7e22ec4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2b60f9d822d00a8deb6b06f3c993fd7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevent_1_1Socket.html#af2b60f9d822d00a8deb6b06f3c993fd7">StartWrite</a> ()=0</td></tr>
<tr class="memdesc:af2b60f9d822d00a8deb6b06f3c993fd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiates an asynchronous write operation.  <a href="#af2b60f9d822d00a8deb6b06f3c993fd7">More...</a><br /></td></tr>
<tr class="separator:af2b60f9d822d00a8deb6b06f3c993fd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fc4e4f040651f3a093e66c2c08d0cc8"><td class="memItemLeft" align="right" valign="top">virtual std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevent_1_1Socket.html#a1fc4e4f040651f3a093e66c2c08d0cc8">Read</a> (void *buf, std::size_t count)=0</td></tr>
<tr class="memdesc:a1fc4e4f040651f3a093e66c2c08d0cc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to read from the socket, returning the number of bytes read.  <a href="#a1fc4e4f040651f3a093e66c2c08d0cc8">More...</a><br /></td></tr>
<tr class="separator:a1fc4e4f040651f3a093e66c2c08d0cc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6584a8f731d63029c8c3011c546db63f"><td class="memItemLeft" align="right" valign="top">virtual std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevent_1_1Socket.html#a6584a8f731d63029c8c3011c546db63f">Write</a> (void *buf, std::size_t count)=0</td></tr>
<tr class="memdesc:a6584a8f731d63029c8c3011c546db63f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to write to the socket, returning the number of bytes written.  <a href="#a6584a8f731d63029c8c3011c546db63f">More...</a><br /></td></tr>
<tr class="separator:a6584a8f731d63029c8c3011c546db63f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Asynchronous (plain or TLS) socket. </p>
<p>See the <a class="el" href="classevent_1_1Socket_1_1Builder.html" title="Options to construct a socket. ">Socket::Builder</a> class for information on how to configure and instantiate sockets. </p>

<p class="definition">Definition at line <a class="el" href="socket_8h_source.html#l00021">21</a> of file <a class="el" href="socket_8h_source.html">socket.h</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a30b24bea86c1560fc6e40615d7e22ec4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30b24bea86c1560fc6e40615d7e22ec4">&#9670;&nbsp;</a></span>StartRead()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void event::Socket::StartRead </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initiates an asynchronous read operation. </p>
<p>The <a class="el" href="structevent_1_1Socket_1_1Watcher.html#ac8c2851231009fc57759484382783df3" title="Called to indicate that you must read from the socket. ">Watcher::CanRead()</a> method will be called when you should call <a class="el" href="classevent_1_1Socket.html#a1fc4e4f040651f3a093e66c2c08d0cc8" title="Attempts to read from the socket, returning the number of bytes read. ">Read()</a> on the socket. A successful read (one that returns any bytes, even if less than requested) will finish the operation, and you must call <a class="el" href="classevent_1_1Socket.html#a30b24bea86c1560fc6e40615d7e22ec4" title="Initiates an asynchronous read operation. ">StartRead()</a> again if you want to keep reading. </p>

<p>Implemented in <a class="el" href="classevent_1_1internal_1_1TlsSocket.html#a642be74f4d7baf00cc5f4608bdedd140">event::internal::TlsSocket</a>, and <a class="el" href="classevent_1_1internal_1_1BasicSocket.html#a797662e8a02ed34ca392320ac5df0576">event::internal::BasicSocket</a>.</p>

</div>
</div>
<a id="af2b60f9d822d00a8deb6b06f3c993fd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2b60f9d822d00a8deb6b06f3c993fd7">&#9670;&nbsp;</a></span>StartWrite()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void event::Socket::StartWrite </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initiates an asynchronous write operation. </p>
<p>The <a class="el" href="structevent_1_1Socket_1_1Watcher.html#ae7a5443a571484e3ed7f0e5d896a4804" title="Called to indicate that you must write to the socket. ">Watcher::CanWrite()</a> method will be called when you should call <a class="el" href="classevent_1_1Socket.html#a6584a8f731d63029c8c3011c546db63f" title="Attempts to write to the socket, returning the number of bytes written. ">Write()</a> on the socket. A successful write (one that consumes any bytes, even if less than requested) will finish the operation, and you must call <a class="el" href="classevent_1_1Socket.html#af2b60f9d822d00a8deb6b06f3c993fd7" title="Initiates an asynchronous write operation. ">StartWrite()</a> again if you still have more bytes to write. </p>

<p>Implemented in <a class="el" href="classevent_1_1internal_1_1TlsSocket.html#a5ab9b94758afe4f3d9d175a13ce2729b">event::internal::TlsSocket</a>, and <a class="el" href="classevent_1_1internal_1_1BasicSocket.html#acf1331a3feafc5adec1416fb43d73695">event::internal::BasicSocket</a>.</p>

</div>
</div>
<a id="a1fc4e4f040651f3a093e66c2c08d0cc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fc4e4f040651f3a093e66c2c08d0cc8">&#9670;&nbsp;</a></span>Read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::size_t event::Socket::Read </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to read from the socket, returning the number of bytes read. </p>
<p>If there was no data immediately available, returns zero. This does not finish the read, so there is no need to call <a class="el" href="classevent_1_1Socket.html#a30b24bea86c1560fc6e40615d7e22ec4" title="Initiates an asynchronous read operation. ">StartRead()</a> again. The <a class="el" href="structevent_1_1Socket_1_1Watcher.html#ac8c2851231009fc57759484382783df3" title="Called to indicate that you must read from the socket. ">Watcher::CanRead()</a> method will be called when you should try again.</p>
<p>For a TLS socket, it's not safe to call this method except as a response to the <a class="el" href="structevent_1_1Socket_1_1Watcher.html#ac8c2851231009fc57759484382783df3" title="Called to indicate that you must read from the socket. ">Watcher::CanRead()</a> callback. A TLS read may be left in a pending state (if renegotiation is triggered). The implementation will make sure no <a class="el" href="structevent_1_1Socket_1_1Watcher.html#ae7a5443a571484e3ed7f0e5d896a4804" title="Called to indicate that you must write to the socket. ">Watcher::CanWrite()</a> callbacks are delivered until the pending read has finished. </p>

<p>Implemented in <a class="el" href="classevent_1_1internal_1_1TlsSocket.html#a82d3f3bc083486dc7b10aace8a633d75">event::internal::TlsSocket</a>, and <a class="el" href="classevent_1_1internal_1_1BasicSocket.html#a55afbee8634ac1cffd756f11016a34cd">event::internal::BasicSocket</a>.</p>

</div>
</div>
<a id="a6584a8f731d63029c8c3011c546db63f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6584a8f731d63029c8c3011c546db63f">&#9670;&nbsp;</a></span>Write()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::size_t event::Socket::Write </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to write to the socket, returning the number of bytes written. </p>
<p>If no bytes could be written without blocking, returns zero. This does not finish the write, so there is no need to call <a class="el" href="classevent_1_1Socket.html#af2b60f9d822d00a8deb6b06f3c993fd7" title="Initiates an asynchronous write operation. ">StartWrite()</a> again. The <a class="el" href="structevent_1_1Socket_1_1Watcher.html#ae7a5443a571484e3ed7f0e5d896a4804" title="Called to indicate that you must write to the socket. ">Watcher::CanWrite()</a> method will be called when you should try again.</p>
<p>For a TLS socket, it's not safe to call this method except as a response to the <a class="el" href="structevent_1_1Socket_1_1Watcher.html#ae7a5443a571484e3ed7f0e5d896a4804" title="Called to indicate that you must write to the socket. ">Watcher::CanWrite()</a> callback. A TLS write may be left in a pending state (if renegotiation is triggered). The implementation will make sure no <a class="el" href="structevent_1_1Socket_1_1Watcher.html#ae7a5443a571484e3ed7f0e5d896a4804" title="Called to indicate that you must write to the socket. ">Watcher::CanWrite()</a> callbacks are delivered until the pending read has finished.</p>
<p>Also for a TLS socket, if you have already tried to write some bytes, you can no longer change your mind afterwards. If the return value indicates that not all bytes were written, the next time you call this method, you must pass in the same contents, to avoid unpredictable behavior. Some of the bytes may already have been copied to the library data structures. </p>

<p>Implemented in <a class="el" href="classevent_1_1internal_1_1TlsSocket.html#ab76fee5fe9033224b7026d8c586871ac">event::internal::TlsSocket</a>, and <a class="el" href="classevent_1_1internal_1_1BasicSocket.html#a636c80d59905e164a5b54864bb554b75">event::internal::BasicSocket</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>event/<a class="el" href="socket_8h_source.html">socket.h</a></li>
<li>event/<a class="el" href="socket_8cc_source.html">socket.cc</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>event</b></li><li class="navelem"><a class="el" href="classevent_1_1Socket.html">Socket</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
