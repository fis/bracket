<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>bracket: event::internal::TlsSocket Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">bracket
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classevent_1_1internal_1_1TlsSocket.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classevent_1_1internal_1_1TlsSocket-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">event::internal::TlsSocket Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>BoringSSL TLS socket.  
 <a href="classevent_1_1internal_1_1TlsSocket.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for event::internal::TlsSocket:</div>
<div class="dyncontent">
<div class="center"><img src="classevent_1_1internal_1_1TlsSocket__inherit__graph.png" border="0" usemap="#event_1_1internal_1_1TlsSocket_inherit__map" alt="Inheritance graph"/></div>
<map name="event_1_1internal_1_1TlsSocket_inherit__map" id="event_1_1internal_1_1TlsSocket_inherit__map">
<area shape="rect" id="node2" href="classevent_1_1Socket.html" title="Asynchronous (plain or TLS) socket. " alt="" coords="5,80,108,107"/>
<area shape="rect" id="node3" href="structevent_1_1Socket_1_1Watcher.html" title="Callback interface for asynchronous socket IO. " alt="" coords="133,80,293,107"/>
<area shape="rect" id="node4" href="classbase_1_1Callback.html" title="Base class for callback interfaces. " alt="" coords="158,5,267,32"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for event::internal::TlsSocket:</div>
<div class="dyncontent">
<div class="center"><img src="classevent_1_1internal_1_1TlsSocket__coll__graph.png" border="0" usemap="#event_1_1internal_1_1TlsSocket_coll__map" alt="Collaboration graph"/></div>
<map name="event_1_1internal_1_1TlsSocket_coll__map" id="event_1_1internal_1_1TlsSocket_coll__map">
<area shape="rect" id="node2" href="classevent_1_1Socket.html" title="Asynchronous (plain or TLS) socket. " alt="" coords="5,80,108,107"/>
<area shape="rect" id="node3" href="structevent_1_1Socket_1_1Watcher.html" title="Callback interface for asynchronous socket IO. " alt="" coords="133,80,293,107"/>
<area shape="rect" id="node4" href="classbase_1_1Callback.html" title="Base class for callback interfaces. " alt="" coords="158,5,267,32"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a269a6843aa3480abad7c110797526e91"><td class="memItemLeft" align="right" valign="top"><a id="a269a6843aa3480abad7c110797526e91"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TlsSocket</b> (const <a class="el" href="classevent_1_1Socket_1_1Builder.html">Socket::Builder</a> &amp;opt)</td></tr>
<tr class="separator:a269a6843aa3480abad7c110797526e91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd38b8c3a4d1824093a6a3df5a97079f"><td class="memItemLeft" align="right" valign="top"><a id="abd38b8c3a4d1824093a6a3df5a97079f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>DISALLOW_COPY</b> (<a class="el" href="classevent_1_1internal_1_1TlsSocket.html">TlsSocket</a>)</td></tr>
<tr class="separator:abd38b8c3a4d1824093a6a3df5a97079f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a642be74f4d7baf00cc5f4608bdedd140"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevent_1_1internal_1_1TlsSocket.html#a642be74f4d7baf00cc5f4608bdedd140">StartRead</a> () override</td></tr>
<tr class="memdesc:a642be74f4d7baf00cc5f4608bdedd140"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiates an asynchronous read operation.  <a href="#a642be74f4d7baf00cc5f4608bdedd140">More...</a><br /></td></tr>
<tr class="separator:a642be74f4d7baf00cc5f4608bdedd140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ab9b94758afe4f3d9d175a13ce2729b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevent_1_1internal_1_1TlsSocket.html#a5ab9b94758afe4f3d9d175a13ce2729b">StartWrite</a> () override</td></tr>
<tr class="memdesc:a5ab9b94758afe4f3d9d175a13ce2729b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiates an asynchronous write operation.  <a href="#a5ab9b94758afe4f3d9d175a13ce2729b">More...</a><br /></td></tr>
<tr class="separator:a5ab9b94758afe4f3d9d175a13ce2729b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82d3f3bc083486dc7b10aace8a633d75"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevent_1_1internal_1_1TlsSocket.html#a82d3f3bc083486dc7b10aace8a633d75">Read</a> (void *buf, std::size_t count) override</td></tr>
<tr class="memdesc:a82d3f3bc083486dc7b10aace8a633d75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to read from the socket, returning the number of bytes read.  <a href="#a82d3f3bc083486dc7b10aace8a633d75">More...</a><br /></td></tr>
<tr class="separator:a82d3f3bc083486dc7b10aace8a633d75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab76fee5fe9033224b7026d8c586871ac"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classevent_1_1internal_1_1TlsSocket.html#ab76fee5fe9033224b7026d8c586871ac">Write</a> (void *buf, std::size_t count) override</td></tr>
<tr class="memdesc:ab76fee5fe9033224b7026d8c586871ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to write to the socket, returning the number of bytes written.  <a href="#ab76fee5fe9033224b7026d8c586871ac">More...</a><br /></td></tr>
<tr class="separator:ab76fee5fe9033224b7026d8c586871ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classevent_1_1Socket"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classevent_1_1Socket')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classevent_1_1Socket.html">event::Socket</a></td></tr>
<tr class="memitem:ac059ff70cae994ce2e95067ac81b93ef inherit pub_methods_classevent_1_1Socket"><td class="memItemLeft" align="right" valign="top"><a id="ac059ff70cae994ce2e95067ac81b93ef"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>DISALLOW_COPY</b> (<a class="el" href="classevent_1_1Socket.html">Socket</a>)</td></tr>
<tr class="separator:ac059ff70cae994ce2e95067ac81b93ef inherit pub_methods_classevent_1_1Socket"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classbase_1_1Callback"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classbase_1_1Callback')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classbase_1_1Callback.html">base::Callback</a></td></tr>
<tr class="memitem:a57a854a0c80028c02584d370bd59340e inherit pub_methods_classbase_1_1Callback"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbase_1_1Callback.html#a57a854a0c80028c02584d370bd59340e">DetachCallback</a> ()</td></tr>
<tr class="memdesc:a57a854a0c80028c02584d370bd59340e inherit pub_methods_classbase_1_1Callback"><td class="mdescLeft">&#160;</td><td class="mdescRight">Immediately detaches the callback from any containers it has been added to.  <a href="classbase_1_1Callback.html#a57a854a0c80028c02584d370bd59340e">More...</a><br /></td></tr>
<tr class="separator:a57a854a0c80028c02584d370bd59340e inherit pub_methods_classbase_1_1Callback"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>BoringSSL TLS socket. </p>

<p class="definition">Definition at line <a class="el" href="socket_8cc_source.html#l00430">430</a> of file <a class="el" href="socket_8cc_source.html">socket.cc</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a642be74f4d7baf00cc5f4608bdedd140"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a642be74f4d7baf00cc5f4608bdedd140">&#9670;&nbsp;</a></span>StartRead()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void event::internal::TlsSocket::StartRead </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initiates an asynchronous read operation. </p>
<p>The <a class="el" href="structevent_1_1Socket_1_1Watcher.html#ac8c2851231009fc57759484382783df3" title="Called to indicate that you must read from the socket. ">Watcher::CanRead()</a> method will be called when you should call <a class="el" href="classevent_1_1internal_1_1TlsSocket.html#a82d3f3bc083486dc7b10aace8a633d75" title="Attempts to read from the socket, returning the number of bytes read. ">Read()</a> on the socket. A successful read (one that returns any bytes, even if less than requested) will finish the operation, and you must call <a class="el" href="classevent_1_1internal_1_1TlsSocket.html#a642be74f4d7baf00cc5f4608bdedd140" title="Initiates an asynchronous read operation. ">StartRead()</a> again if you want to keep reading. </p>

<p>Implements <a class="el" href="classevent_1_1Socket.html#a30b24bea86c1560fc6e40615d7e22ec4">event::Socket</a>.</p>

<p class="definition">Definition at line <a class="el" href="socket_8cc_source.html#l00511">511</a> of file <a class="el" href="socket_8cc_source.html">socket.cc</a>.</p>

</div>
</div>
<a id="a5ab9b94758afe4f3d9d175a13ce2729b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ab9b94758afe4f3d9d175a13ce2729b">&#9670;&nbsp;</a></span>StartWrite()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void event::internal::TlsSocket::StartWrite </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initiates an asynchronous write operation. </p>
<p>The <a class="el" href="structevent_1_1Socket_1_1Watcher.html#ae7a5443a571484e3ed7f0e5d896a4804" title="Called to indicate that you must write to the socket. ">Watcher::CanWrite()</a> method will be called when you should call <a class="el" href="classevent_1_1internal_1_1TlsSocket.html#ab76fee5fe9033224b7026d8c586871ac" title="Attempts to write to the socket, returning the number of bytes written. ">Write()</a> on the socket. A successful write (one that consumes any bytes, even if less than requested) will finish the operation, and you must call <a class="el" href="classevent_1_1internal_1_1TlsSocket.html#a5ab9b94758afe4f3d9d175a13ce2729b" title="Initiates an asynchronous write operation. ">StartWrite()</a> again if you still have more bytes to write. </p>

<p>Implements <a class="el" href="classevent_1_1Socket.html#af2b60f9d822d00a8deb6b06f3c993fd7">event::Socket</a>.</p>

<p class="definition">Definition at line <a class="el" href="socket_8cc_source.html#l00520">520</a> of file <a class="el" href="socket_8cc_source.html">socket.cc</a>.</p>

</div>
</div>
<a id="a82d3f3bc083486dc7b10aace8a633d75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82d3f3bc083486dc7b10aace8a633d75">&#9670;&nbsp;</a></span>Read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t event::internal::TlsSocket::Read </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to read from the socket, returning the number of bytes read. </p>
<p>If there was no data immediately available, returns zero. This does not finish the read, so there is no need to call <a class="el" href="classevent_1_1internal_1_1TlsSocket.html#a642be74f4d7baf00cc5f4608bdedd140" title="Initiates an asynchronous read operation. ">StartRead()</a> again. The <a class="el" href="structevent_1_1Socket_1_1Watcher.html#ac8c2851231009fc57759484382783df3" title="Called to indicate that you must read from the socket. ">Watcher::CanRead()</a> method will be called when you should try again.</p>
<p>For a TLS socket, it's not safe to call this method except as a response to the <a class="el" href="structevent_1_1Socket_1_1Watcher.html#ac8c2851231009fc57759484382783df3" title="Called to indicate that you must read from the socket. ">Watcher::CanRead()</a> callback. A TLS read may be left in a pending state (if renegotiation is triggered). The implementation will make sure no <a class="el" href="structevent_1_1Socket_1_1Watcher.html#ae7a5443a571484e3ed7f0e5d896a4804" title="Called to indicate that you must write to the socket. ">Watcher::CanWrite()</a> callbacks are delivered until the pending read has finished. </p>

<p>Implements <a class="el" href="classevent_1_1Socket.html#a1fc4e4f040651f3a093e66c2c08d0cc8">event::Socket</a>.</p>

<p class="definition">Definition at line <a class="el" href="socket_8cc_source.html#l00529">529</a> of file <a class="el" href="socket_8cc_source.html">socket.cc</a>.</p>

</div>
</div>
<a id="ab76fee5fe9033224b7026d8c586871ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab76fee5fe9033224b7026d8c586871ac">&#9670;&nbsp;</a></span>Write()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t event::internal::TlsSocket::Write </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to write to the socket, returning the number of bytes written. </p>
<p>If no bytes could be written without blocking, returns zero. This does not finish the write, so there is no need to call <a class="el" href="classevent_1_1internal_1_1TlsSocket.html#a5ab9b94758afe4f3d9d175a13ce2729b" title="Initiates an asynchronous write operation. ">StartWrite()</a> again. The <a class="el" href="structevent_1_1Socket_1_1Watcher.html#ae7a5443a571484e3ed7f0e5d896a4804" title="Called to indicate that you must write to the socket. ">Watcher::CanWrite()</a> method will be called when you should try again.</p>
<p>For a TLS socket, it's not safe to call this method except as a response to the <a class="el" href="structevent_1_1Socket_1_1Watcher.html#ae7a5443a571484e3ed7f0e5d896a4804" title="Called to indicate that you must write to the socket. ">Watcher::CanWrite()</a> callback. A TLS write may be left in a pending state (if renegotiation is triggered). The implementation will make sure no <a class="el" href="structevent_1_1Socket_1_1Watcher.html#ae7a5443a571484e3ed7f0e5d896a4804" title="Called to indicate that you must write to the socket. ">Watcher::CanWrite()</a> callbacks are delivered until the pending read has finished.</p>
<p>Also for a TLS socket, if you have already tried to write some bytes, you can no longer change your mind afterwards. If the return value indicates that not all bytes were written, the next time you call this method, you must pass in the same contents, to avoid unpredictable behavior. Some of the bytes may already have been copied to the library data structures. </p>

<p>Implements <a class="el" href="classevent_1_1Socket.html#a6584a8f731d63029c8c3011c546db63f">event::Socket</a>.</p>

<p class="definition">Definition at line <a class="el" href="socket_8cc_source.html#l00570">570</a> of file <a class="el" href="socket_8cc_source.html">socket.cc</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>event/<a class="el" href="socket_8cc_source.html">socket.cc</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>event</b></li><li class="navelem"><b>internal</b></li><li class="navelem"><a class="el" href="classevent_1_1internal_1_1TlsSocket.html">TlsSocket</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
